# 多把锁

原始需求：sleep方法和study方法加锁，只能单个线程调用执行；

如下代码：在sleep和study方法上加了锁后，sleep和study也互斥，降低了并发性

```java
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class BigRoom {
    public void sleep(){
        synchronized (this){
            log.debug("sleep...");
        }
    }

    public void study(){
        synchronized (this){
            log.debug("study...");
        }
    }
}
```

解决方法：

```java
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class BigRoom {

    private BigRoom studyRoom = new BigRoom();
    private BigRoom sleepRoom = new BigRoom();

    public void sleep(){
        synchronized (sleepRoom){
            log.debug("sleep...");
        }
    }

    public void study(){
        synchronized (studyRoom){
            log.debug("study...");
        }
    }
}
```

将锁的粒度细分：

- 好处：是可以增强并发性
- 坏处： 如果一个线程需要同时获得多把锁，就容易发生死锁

