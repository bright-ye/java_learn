# Wait和Notify

## 同步模式之保护性暂停

即Guarded Suspension，用在一个线程等待另一个线程的执行结果：

1. 有一个结果需要从一个线程传递到另一个线程，让他们关联同一个GuardedObject
2. 如果有结果不断从一个线程到另一个线程，那么可以使用消息队列(生产者/消费者)
3. JDK中，join的实现、Future的实现，采用的就是此模式
4. 因为要等待另一个结果，因此归类到同步模式

![1594473284105](7.wait和notify.assets/1594473284105.png)

多任务版的GuardedObject图中Futures就好比信箱，左侧的t0, t2,t4就好比等待邮件的居民，右侧的t1/t3/t5就好比邮递员如果需要在多个类之间使用GuardedObject对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅能解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理。

![1594518049426](7.wait和notify.assets/1594518049426.png)



## 异步模式之生产者/消费者

1. 与前面的保护性暂停中的GuardedObject不同，不需要产生结果和消费结果的线程一一对应。
2. 消费队列可以用来平衡生产和消费的线程资源
3. 生产者仅负责产生结果数据，不关系数据如何处理，而消费者专心处理结果数据
4. 消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据
5. JDK中各种阻塞队列，采用的就是这种模式

**异步**的意思就是生产者产生消息之后消息没有立即被消费掉，而"同步模式"中，消息在产生后被立即消费了

![1594524622020](7.wait和notify.assets/1594524622020-163506115891012.png)



# Park和Unpark

## 基本使用

```java
// 暂停当前线程
LockSupport.park();
// 恢复某个线程的运行
LockSupport.unpark();
```

## park和unpark原理

每个线程都有自己的一个Parker对象，由三部分组成：_counter, _cond 和 _mutex

1. 线程就像一个旅人，Parker就像他随身携带的背包，条件变量_cond就好比背包中的帐篷，_counter就好比背包中的备用干粮（0耗尽，1为充足）
2. 调用park就是看需不需要停下来歇息
   1. 如果备用干粮耗尽，那么钻进帐篷歇息
   2. 如果备用干粮充足，那么不需要停留，继续前进
3. 调用unpark，就好比干粮充足
   1. 如果这时线程还在帐篷，就唤醒让他继续前进
   2. 如果这时线程还在运行，那么下次他调用park时，仅是消耗掉备用干粮，不需要停留继续前进

## 先调用park再调用unpark的过程

1. 先调用park

   1. 当前线程调用Unsafe.park()方法
   2. 检查_counter, 本情况为0，这时获得`_mutex`锁（`_mutex`对象有个等待队列`_cond`）
   3. 线程进入`_cond`条件变量阻塞
   4. 设置`_counter`为0

   ![1594531894163](7.wait和notify.assets/20200712133136-910801.png)

2. 调用unpark

   1. 调用Unsafe.unpark(Thread-0)方法，设置`_counter`为0
   2. 唤醒`_cond`条件变量中的thread-0
   3. thread-0恢复运行
   4. 设置`_counter`为0

   ![1594532057205](7.wait和notify.assets/1594532057205-163506895312115.png)



## 先调用unpark再调用park的过程

1. 调用Unsafe.unpark(Thread_0)的方法，设置_counter为1
2. 当前线程调用Unsafe.park()方法
3. 检查_counter，本情况为1，这时线程无需阻塞，继续运行
4. 设置_counter为0

![1594532135616](7.wait和notify.assets/20200712133539-357066.png)

# 特点

与Object的wait和notify相比：

- wait, notify, notifyAll 必须配合Object Monitor一起使用，而unpark不必
- park,unpark是以线程为单位来【阻塞】和【唤醒】线程，而notify只能随机唤醒一个线程，notifyAll是唤醒所有线程，就不那么【精确】
- park 和 unpark 可以先unpark，而wait和notify 不能先notify

