# 垃圾回收

## 1. 如何判断对象可以回收

### 1.1 引用计数器

对象每被引用一次，就计数加1，如果计数为0，则表示没有被引用。

引用计数法存在一个缺陷：A对象引用B对象，B对象引用A对象，产生了循环引用

### 1.2 可达性分析算法

- Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象
- 扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收
- 哪些对象可以作为GC Root?
- 强引用、软引用、弱引用的区别
  - 强引用顾名思义
  - 软引用：gc后若内存不够，会回收软引用对象；弱引用：不管内存够不够，gc都会回收
- 虚引用、终结器引用
  - 虚引用Buffer：直接内存，当释放直接内存时，虚引用对象放入到了引用队列，会调用虚引用对象的Unsafe.freeMemory来回收直接内存
  - 终结器引用finallize：当对象被回收后，jvm会给对象创建一个终结器引用并放入到引用队列中，jvm会启动finallize线程在某个时机回收对象

### 1.3 四种引用

1. 强引用
   - 只有GC Roots对象都不通过【强引用】引用该对象，该对象才能被垃圾回收
2. 软引用（SoftReference）
   - 仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次触发垃圾回收，回收软引用对象
   - 可以配合引用队列来释放引用自身
3. 弱引用（WeakReference）
   - 仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象
   - 可以使用配合引用队列来释放引用自身
4. 虚引用（PhantomReference）
   - 必须配合引用队列使用，主要配合ByteBuffer使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存
5. 终结器引用（FinalReference）
   - 无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器入队（被引用对象暂时没有被回收），再由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize方法，第二次GC时才能回收被引用对象

代码案例：

https://blog.csdn.net/weixin_50280576/article/details/113775575?spm=1001.2014.3001.5501

## 2. 垃圾回收算法

### 2.1 标记清除法

Mark Sweep

- 速度较快
- 会产生内存碎片

![在这里插入图片描述](../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70.png)

### 2.2 标记整理

Mark Compact

- 速度慢

- 没有内存碎片

  ![在这里插入图片描述](../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70-16374169632362.png)

### 2.3 复制

Copy

- 不会有内存碎片

- 需要占用两倍内存空间

  ![在这里插入图片描述](../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70-16374170284224.png)

## 3. 分代垃圾回收

## 4. 垃圾回收器

## 5.垃圾回收调优

