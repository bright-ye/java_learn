# 线程状态转换

## 1.  New <---> RUNNABLE

- 当调用t.start()方法时，由new ----> runnable

## 2. RUNNABLE <---> WAITING

1. 线程用synchronized(obj)获取对象锁
   1. 调用obj.wait方法时，t线程从runnable ----> waiting
   2. 调用obj.notify、obj.notifyAll、t.interrupt时
      1. 竞争锁成功，t 线程从waiting ----> runnable
      2. 竞争锁失败，t 线程从waiting -----> blocked
   3. wait是可以释放锁的，sleep是不释放锁

```java
import lombok.extern.slf4j.Slf4j;
import java.util.concurrent.TimeUnit;
@Slf4j
public class TestWaitNotify {
    public static void main(String[] args) {
        final Object obj = new Object();
        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行...");
                try {
                    obj.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其他代码...");
            }
        }, "t1").start();

        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行...");
                try {
                    obj.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其他代码...");
            }
        }, "t2").start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.debug("唤醒obj上其他线程");
        synchronized (obj) {
            obj.notifyAll();
        }
    }
}
```

## 3. RUNNABLE <---> WAITING

- 当前线程调用 t.join() 方法时，当前线程从runnable ---> waiting
  - 注意是当前线程在 t 线程对象的监视器上等待

- t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 waiting ----> runnable

## 4. RUNNABLE <---> WAITING

- 当前线程调用了LockSupport.park()方法会让当前线程从RUNNABLE ---> WAITING
- 调用LockSupport.unpark(目标线程) 或调用了 线程的interrupt()，会让目标线程从 WAITING ----> RUNNABLE

## 5. RUNNABLE <----> TIME_WATING

1. 当前线程调用t.join(long n)方法时，当前线程从RUNNABLE  ---->  TIME_WAITING 注意是当前线程在 t 线程对象的监视器上等待
2. 当前时间超过了 n 毫秒，或 t 线程运行结束，或调用了 当前线程的 interrupt() 时，当前线程 从TIME_WAITING ->  RUNNABLE

## 6. RUNNABLE <---> TIME_WAITING

1. 当前线程调用 Thread.sleep(long n) ， 当前线程从 RUNNABLE ----> time_waiting
2. 当前线程等待时间超过了 n 毫秒或调用了线程的 interrupt()， 当前线程 从 TIME_WAITING  ----> RUNNABLE

## 7. RUNNABLE <--------> TIME_WAITING

1. 当前线程调用LockSupport.parkNanos(long nanos) 或 LockSupport.parkUnit(long millis) 时，当前线程从 RUNNABLE ----> time_waiting
2. 调用LockSupport.unpark(目标线程) 或调用线程的 interrupt()时，或是等待超时，会让目标从 TIME_WAITING ---> RUNNABLE





