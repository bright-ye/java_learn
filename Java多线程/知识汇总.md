

# 并发编程

## 并发和并行的概念

- 并发concurrent：同一时间应对多件事，cpu在多个线程上下快速切换
- 并行parallel：同一时间做多件事，cpu多个核心同时执行多个线程

## 异步和同步

- 同步：需要等待结果才能继续运行

- 异步：不需要等待结果就能返回

## 创建线程的方法

### 1. 直接使用Thread

```java
public class Test1 {

    public static void main(String[] args) {

        // 1.创建线程
        Thread t = new Thread() {
            // 2. 线程要执行的任务
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + " running...");
            }
        };

        t.start();

        System.out.println(Thread.currentThread().getName() + " running...");
    }

}
```

### 2. 使用Runnable配合Thread

线程和任务分离开来

```java
public class Test2 {

    public static void main(String[] args) {

        // 线程要执行的任务
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + " running...");
            }
        };

        // 2. 创建线程
        new Thread(runnable).start();

        System.out.println(Thread.currentThread().getName() + " running...");
    }

}
```

Runnable的创建也可以使用lambda表达式来处理：

```java
@Test
public void test2() {
    Runnable runnable = () -> {
        System.out.println(Thread.currentThread().getName() + " running...");
    };
}
```

### 3. 使用FutureTask、Callable、Thread组合获取线程返回值

```java
public class Test3 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask<Integer> futureTask = new FutureTask<>(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                Thread.sleep(1000);
                return 100;
            }
        });

        Thread t = new Thread(futureTask, "futureTask thread");
        t.start();

        System.out.println(futureTask.get());
    }
}
```

## idea设置多线程debug模式

断点上右击，把 All 改成 Thread，有多个线程的话，需要在多个断点上都需要设置

![image-20210915232150004](%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.assets/image-20210915232150004.png)

## 线程上下文切换

cpu在运行线程过程中，可能会暂停执行当前线程，转而执行其他线程，发生这样的原因通常有：

- 线程的cpu时间片用完
- 垃圾回收
- 有更高优先级的线程需要执行
- 线程调用了sleep、yield、wait、join、park、synchronized、lock等方法

当Context Switch发生时，需要由操作系统保存当前线程的状态，恢复另一个线程的状态，Java中对应的概念就是程序计数器Program Counter Register，它的作用是记住下一个jvm指令的执行地址，是线程私有的。

- Context Switch频繁发生会影响性能
- 状态包括了程序计数器、虚拟机栈中每个栈的信息，如局部变量、操作数栈、返回地址等

## 线程方法API

- start()

  启动线程，线程以异步的方式来执行；

  启动一次后，不可以再重复调用，否则会出现异常

- run()

  启动异步线程后，线程run方法中的内容；

  如果直接调用run方法，那么run方法就相当于是一个普通方法，被他所在的那个线程调用，也就是同步执行，不会异步执行

- state

  线程状态

- sleep

  sleep方法，会让线程进入睡眠，此时线程的状态是time waiting；

  其他线程可以使用interrupt方法打断正在睡眠的线程，这时sleep线程会抛出InterruptedException，sleep线程继续执行；

  sleep结束的线程未必会立即得到执行；

  建议使用TimeUnit的sleep代替Thread的sleep来获得更好的可读性；

- yield

  调用yield方法会让当前线程从running进入runnable就绪状态，然后调度其他线程；

  注意：调用了yield方法，并不会切换到别的线程，具体的线程依赖于操作系统的任务调度

- 线程优先级setPriority

  线程优先级会提示cpu调度器优先调度该线程；

  如果在cpu比较忙时，优先级高的线程会获得更多的时间片，但cpu闲时，优先级几乎没有作用

- isInterrupted

  判断是否被打断，不会清除**打断标记**

- isAlive

  判读线程是否还存活

- interrupt

  打断线程，如果线程正在sleep, wait, join会导致被打断的线程抛出InterruptedException，并清除打断标记；

  如果打断正在运行的线程，则会设置打断标记

  ```java
  	public static void main(String[] args) {
          Thread thread = new Thread(()->{
              try {
                  TimeUnit.SECONDS.sleep(5);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          });
          thread.start();
  
          try {
              TimeUnit.SECONDS.sleep(1);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
  
          thread.interrupt();	// 打断sleep的线程，会清除标记;打断running的线程，打断标记为false
          System.out.println("线程状态：" + thread.getState() + " 打断标记：" + thread.isInterrupted());
      }
  ```

  输出结果：

  ```java
  java.lang.InterruptedException
  	at java.lang.Thread.sleep(Native Method)
  	at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)
  	at com.mylearn.thread.Test6.lambda$main$0(Test6.java:9)
  	at com.mylearn.thread.Test6$$Lambda$1/0x0000000000000000.run(Unknown Source)
  	at java.lang.Thread.run(Thread.java:823)
  线程状态：RUNNABLE 打断标记：false
  ```

  如果打断的线程是running的状态，打断标记会被置为true，但也仅仅是将打断标记置为了true，线程仍然会继续执行。

  ```java
  public static void main(String[] args) {
      Thread thread = new Thread(()->{
          while(true){
              if(Thread.currentThread().isInterrupted()){
                  break;
              }
              System.out.println(1);
          }
      });
      thread.start();
      thread.interrupt();
      System.out.println("线程状态：" + thread.getState() + " 打断标记：" + thread.isInterrupted());
  }
  ```

- interrupted

  判断当前线程是否被打断，会清除打断标记

- currentedThread

  获取当前正在执行的线程

- join

  a线程调用b线程的join方法，a线程会等待b线程执行完后再继续执行。

  ```java
  static int res = 0;
  
  public static void main(String[] args) {
      Thread thread = new Thread(() -> {
          try {
              TimeUnit.SECONDS.sleep(1);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          res = 10;
      });
      thread.start();
      try {
          thread.join();
      } catch (InterruptedException e) {
          e.printStackTrace();
      }
      System.out.println(res);
  }
  ```

  如果有多个线程时，主线程可以调用多个线程的join方法，使得main线程等待所有线程都执行完再继续执行main线程。

  ```java
  	static int r1 = 0;
      static int r2 = 0;
      public static void main(String[] args) {
          Thread thread1 = new Thread(()->{
              r1 = 10;
              try {
                  TimeUnit.SECONDS.sleep(1);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          });
          Thread thread2 = new Thread(()->{
              r2 = 20;
              try {
                  TimeUnit.SECONDS.sleep(2);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          });
  
          thread1.start();
          thread2.start();
          long start = System.currentTimeMillis();
  
          try {
              thread1.join();
              thread2.join();
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.println(System.currentTimeMillis() - start);
      }
  ```

  join方法也可以指定时间来等待。





## 两阶段终止模式

### 概念

在一个线程T1中，如何优雅的终止线程T2？

### 错误思路

1. 使用线程的stop方法

   stop方法会真正杀死进程，如果这时线程锁住了共享资源，那么当它被杀死后，再也没机会释放锁，其他线程永远无法获取锁

2. 使用System.exit(1)

   这种做法会让整个程序都停止。

### 正确思路

```java
	public static void main(String[] args) throws InterruptedException {
        TwoPhaseTermination twoPhaseTermination = new TwoPhaseTermination();
        twoPhaseTermination.start();
        TimeUnit.SECONDS.sleep(5);
        twoPhaseTermination.stop();
    }

    static class TwoPhaseTermination {
        private Thread monitorThread;

        public void start() {
            monitorThread = new Thread(() -> {
                while (true) {
                    Thread current = Thread.currentThread();
                    if (current.isInterrupted()) {
                        System.out.println("料理后事");
                        break;
                    }
                    try {
                        TimeUnit.SECONDS.sleep(1);
                        System.out.println("running monitor");
                    } catch (InterruptedException e) {
                        current.interrupt();
                    }
                }
            });
            monitorThread.start();
        }

        public void stop() {
            monitorThread.interrupt();
        }
    }
```

## 打断park的线程

可以使用工具类LockSupport来使线程暂停，可以使用interrupt打断正在park的线程，被打断的park线程无法再次park，除非清除打断标记。

```java
	public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            System.out.println("park...");
            LockSupport.park();
            System.out.println("unpark");
            LockSupport.park();
            System.out.println("打断标记: " + Thread.currentThread().isInterrupted());
            System.out.println("打断标记: " + Thread.interrupted());
            LockSupport.park();

        });
        t1.start();

        TimeUnit.SECONDS.sleep(1);
        t1.interrupt();
    }
```

## 过时不推荐的方法

- stop
- suspend
- resume

## 主线程和守护线程

设置守护线程： setDaemon(true)







